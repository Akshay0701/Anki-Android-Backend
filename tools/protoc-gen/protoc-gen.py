#!/usr/bin/env python

# Generates BackendService.java from backend.proto
# This is the serialization mechanism/calling conventions for protobufs between rslib and rsdroid

import sys

from google.protobuf.compiler import plugin_pb2 as plugin


class RPC:
    def __init__(self, service, command_num):
        self.method = service
        self.command_num = command_num

    def is_valid(self):
        return self.get_input() and self.get_output()

    def parse(self, str, input):
        if input:
            return self.parse_input(str)
        else:
            return self.parse_output(str)

    @staticmethod
    def parse_input(str):
        if str == ".BackendProto.Empty":
            return "()"
        return "(" + str.replace(".BackendProto.", "Backend.") + " args)"

    @staticmethod
    def parse_output(str):
        if str == ".BackendProto.Empty":
            return "void"
        return str.replace(".BackendProto.", "Backend.")

    def get_input(self):
        return self.parse(self.method.input_type, True)

    def get_output(self):
        return self.parse(self.method.output_type, False)

    def __repr__(self):
        args = "args.toByteArray()" if self.get_input() != "()" else "Backend.Empty.getDefaultInstance().toByteArray()"
        # These previously were very different - validation changed this.
        # Might want to merge these branches now they're so similar.
        if self.get_output() == "void":
            return "    public {out} {name}{inv} throws BackendException {{ \n" \
                   "        try {{\n" \
                   "            Pointer backendPointer = ensureBackend();\n" \
                   "            byte[] result = NativeMethods.command(backendPointer.toJni(), {num}, {args});\n" \
                   "            Backend.Empty message = Backend.Empty.parseFrom(result);\n" \
                   "            validateMessage(result, message);\n" \
                   "        }} catch (InvalidProtocolBufferException ex) {{\n" \
                   "            throw new BackendException(ex);\n" \
                   "        }}\n" \
                   "    }}".format(out=self.get_output(), name=self.method_name(), inv=self.get_input(),
                                   num=self.command_num,
                                   args=args)
        else:
            return "    public {out} {name}{inv} throws BackendException {{ \n" \
                   "        try {{\n" \
                   "            Pointer backendPointer = ensureBackend();\n" \
                   "            byte[] result = NativeMethods.command(backendPointer.toJni(), {num}, {args});\n" \
                   "            {out} message = {out}.parseFrom(result);\n" \
                   "            validateMessage(result, message);\n" \
                   "            return message;\n" \
                   "        }} catch (InvalidProtocolBufferException ex) {{\n" \
                   "            throw new BackendException(ex);\n" \
                   "        }}\n" \
                   "    }}".format(out=self.get_output(), name=self.method_name(), inv=self.get_input(),
                                   num=self.command_num,
                                   args=args)

    def method_name(self):
        return self.method.name[0].lower() + self.method.name[1:]


def traverse(proto_file):
    classes = []
    for f in proto_file.service:
        for i, m in enumerate(f.method):
            cls = RPC(m, i+1)
            if not cls.is_valid():
                raise ValueError(str(m))
            classes.append(cls)

    return classes


def log(s):
    sys.stderr.write(str(s) + "\n")


def generate_code(request, response):
    for proto_file in request.proto_file:

        service_methods = traverse(proto_file)
        if not service_methods:
            continue
        class_name = proto_file.name.capitalize().replace(".proto", "") + "Service"
        file_contents = ["/*\n "
                         "  This class was autogenerated from {} by {}\n"
                         "  Please Rebuild project to regenerate."
                         " */\n\n"
                         "package net.ankiweb.rsdroid;\n\n"
                         "import com.google.protobuf.InvalidProtocolBufferException;\n"
                         "import com.google.protobuf.GeneratedMessageV3;\n\n"
                         "import BackendProto.Backend;\n\n"
                         "public abstract class {} {{\n\n"
                         "    public abstract Pointer ensureBackend();\n\n\n"
                         "    private void validateMessage(byte[] result, GeneratedMessageV3 message) throws BackendException, InvalidProtocolBufferException {{\n"
                         "        if (message.getUnknownFields().asMap().isEmpty()) {{\n"
                         "            return;\n"
                         "        }}\n"
                         "        Backend.BackendError ex = Backend.BackendError.parseFrom(result);\n"
                         "        throw new BackendException(ex.getLocalized());\n"
                         "    }}".format(proto_file.name, __file__, class_name)]

        for method in service_methods:
            file_contents.append("\n\n" + str(method))

        file_contents.append("\n}")

        # Fill response
        f = response.file.add()
        f.name = class_name + ".java"
        f.content = "\n".join(file_contents)


if __name__ == '__main__':
    # Read request message from stdin
    data = sys.stdin.buffer.read()

    # Parse request
    request = plugin.CodeGeneratorRequest()
    request.ParseFromString(data)

    # Create response
    response = plugin.CodeGeneratorResponse()

    # Generate code
    generate_code(request, response)

    # Serialise response message
    output = response.SerializeToString()

    # Write to stdout
    sys.stdout.buffer.write(output)
